<?php
/*
 *  Copyright (C) 2020-2025 Universität zu Köln
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

namespace ThomasInstitut\DataCache;

use InvalidArgumentException;
use RuntimeException;

/**
 * A DataCache that stores its data in a directory with
 * one file per cached item.
 */
class DirectoryDataCache implements DataCache
{
    const string NO_EXPIRATION_STRING = '0';

    const array BANNED_CHARACTERS = [ '*', '/'];

    private string $cachePath;
    private string $cacheName;
    private string $fileExtension;
    private int $defaultTtl;
    private bool $useHashes;
    private string $separator;


    /**
     * Constructs a directory data cache using the given path.
     *
     * `$cacheName` will be used as a prefix for all files generated by the cache. It cannot be empty, and it
     * cannot contain the separator character or a dot if `$fileExtension` is not empty. It cannot contain
     * `*` or `/` either.
     *
     * `$separator` is a single character other than `*` or `/` or dot. If `$fileExtension` is empty, a dot can be used
     * as a separator as well.
     *
     * By default, if `$alwaysUseKeyHashes` is false, the cache will try to use item's key to construct the name of
     * the item's file. When this is not possible (because, for example, the key contains invalid file name characters),
     * or if `$alwaysUseKeyHashes` is true, a hash of the key will be used instead.
     *
     * @param string $directoryPath
     * @param string $cacheName
     * @param string $fileExtension
     * @param string $separator
     * @param bool $alwaysUseKeyHashes
     */
    public function __construct(
        string $directoryPath,
        string $cacheName,
        string $fileExtension = 'txt',
        string $separator = '-',
        bool $alwaysUseKeyHashes = false
    ) {
        if (strlen($cacheName) === 0) {
            throw new InvalidArgumentException("Invalid cache name '$cacheName'");
        }

        if (strlen($separator) !== 1 || in_array($separator, self::BANNED_CHARACTERS)) {
            throw new InvalidArgumentException("Invalid separator character '$separator'");
        }

        if (str_contains($fileExtension, '.')) {
            throw new InvalidArgumentException("Invalid file extension '$fileExtension'");
        }

        $bannedCharacters = self::BANNED_CHARACTERS;

        if ($fileExtension !== '') {
            if ($separator === '.') {
                throw new InvalidArgumentException("Invalid separator character '$separator'");
            }
            $bannedCharacters[] = '.';
        }
        $bannedCharacters[] = $separator;
        foreach ($bannedCharacters as $char) {
            if (str_contains($cacheName, $char)) {
                throw new InvalidArgumentException("Invalid character '$char' in cache name '$cacheName'");
            }
            if (str_contains($fileExtension, $char)) {
                throw new InvalidArgumentException("Invalid character '$char' in file extension '$fileExtension'");
            }
        }

        $this->cachePath = realpath($directoryPath);
        $this->cacheName = $cacheName;
        $this->fileExtension = $fileExtension;
        $this->defaultTtl = 0;
        $this->useHashes = $alwaysUseKeyHashes;
        $this->separator = $separator;
    }

    private function getActualKey(string $key) : string
    {
        if ($this->useHashes || !$this->canBePartOfFileName($key)) {
            return hash('sha256', $key);
        }
        return $key;
    }

    /**
     * @inheritDoc
     */
    public function get(string $key): string
    {
        $filePath = $this->getNonExpiredFileNameForKey($key);
        if ($filePath === null) {
            throw new ItemNotInCacheException();
        }
        $value = file_get_contents($filePath);
        if ($value === false) {
            throw new RuntimeException("Could not read cache file '$key'"); // @codeCoverageIgnore
        }
        return $value;
    }

    private function getNonExpiredFileNameForKey(string $key): ?string
    {
        $filePaths = glob($this->getFilePathForKey($key, '*'));
        if (count($filePaths) === 0) {
            return null;
        }
        $now = time();
        foreach ($filePaths as $filePath) {
            [, $expirationTimestamp] = $this->getKeyAndExpirationTimeFromFilePath($filePath);
            if ($expirationTimestamp === 0 || $expirationTimestamp > $now) {
                return $filePath;
            }
        }
        return null;
    }

    private function getFilePathForKey(string $key, string $expires): string
    {
        $actualKey = $this->getActualKey($key);
        $fileName =  $this->cachePath . '/' . implode($this->separator, [$this->cacheName, $actualKey, $expires]);
        if ($this->fileExtension !== '') {
            $fileName .= '.' . $this->fileExtension;
        }
        return $fileName;
    }

    private function getAllFilePathsInCache(): array
    {
        return glob("$this->cachePath/$this->cacheName*");
    }

    private function getKeyAndExpirationTimeFromFilePath(string $filePath): array
    {
        $fileName = preg_replace("/\.$this->fileExtension$/", '', basename($filePath));
        [, $key, $expires] = explode($this->separator, $fileName);
        $expirationTimestamp = $expires === self::NO_EXPIRATION_STRING ? 0 : intval($expires);
        return [$key, $expirationTimestamp];
    }

    /**
     * @inheritDoc
     */
    public function getRemainingTtl(string $key): int
    {
        return -1;
    }

    /**
     * @inheritDoc
     */
    public function isInCache(string $key): bool
    {
        return $this->getNonExpiredFileNameForKey($key) !== null;
    }

    /**
     * @inheritDoc
     */
    public function set(string $key, string $value, int $ttl = -1): void
    {

        $this->delete($key);

        if ($ttl < 0) {
            $ttl = $this->defaultTtl;
        }
        $expires = self::NO_EXPIRATION_STRING;
        if ($ttl > 0) {
            $expires = strval(time() + $ttl);
        }

        file_put_contents($this->getFilePathForKey($key, $expires), $value);
    }

    /**
     * @inheritDoc
     */
    public function delete(string $key): void
    {
        $filePaths = glob($this->getFilePathForKey($key, '*'));
        foreach ($filePaths as $filePath) {
            unlink($filePath);
        }
    }

    private function canBePartOfFileName(string $key): bool
    {
        $bannedCharacters = self::BANNED_CHARACTERS;
        $bannedCharacters[] = $this->separator;
        for ($i = 0; $i < 20; $i++) {
            $bannedCharacters[] = chr($i);
        }
        for ($i = 0; $i < strlen($key); $i++) {
            $ch = $key[$i];
            if (in_array($ch, $bannedCharacters)) {
                return false;
            }
        }
        return true;
    }

    /**
     * @inheritDoc
     */
    public function setDefaultTtl(int $ttl): void
    {
        if ($ttl >= 0) {
            $this->defaultTtl = $ttl;
        }
    }

    /**
     * @inheritDoc
     */
    public function flush(): void
    {
        foreach ($this->getAllFilePathsInCache() as $filePath) {
            unlink($filePath);
        }
    }

    /**
     * @inheritDoc
     */
    public function clean(): void
    {
        $now = time();
        foreach ($this->getAllFilePathsInCache() as $filePath) {
            [, $expirationTimestamp] = $this->getKeyAndExpirationTimeFromFilePath($filePath);
            if ($expirationTimestamp !== 0 && $expirationTimestamp < $now) {
                unlink($filePath);
            }
        }
    }
}
